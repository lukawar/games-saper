<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Saper</title>
  <style>
    body { display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background-color: #333; }
    #board { display: grid; grid-template-columns: repeat(10, 30px); grid-template-rows: repeat(10, 30px); gap: 2px; }
    .cell { width: 30px; height: 30px; display: flex; justify-content: center; align-items: center; background-color: #888; color: #fff; font-size: 1.2em; cursor: pointer; }
    .cell.revealed { background-color: #bbb; cursor: default; }
    .cell.mine { background-color: red; }
  </style>
</head>
<body>
  <div id="board"></div>

  <script>
    const boardSize = 10;
    const mineCount = 15;
    const board = document.getElementById("board");
    let gameOver = false;

    // board
    const cells = Array(boardSize * boardSize).fill().map((_, index) => ({
      id: index,
      mine: false,
      revealed: false,
      adjacentMines: 0,
    }));

    // randomize mines pos
    function placeMines() {
      let minesPlaced = 0;
      while (minesPlaced < mineCount) {
        const randomIndex = Math.floor(Math.random() * cells.length);
        if (!cells[randomIndex].mine) {
          cells[randomIndex].mine = true;
          minesPlaced++;
        }
      }
    }

    // calculate mines
    function calculateAdjacentMines() {
      for (let i = 0; i < cells.length; i++) {
        const { x, y } = getXY(i);
        if (!cells[i].mine) {
          let mineCounter = 0;
          for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx;
              const ny = y + dy;
              if (nx >= 0 && ny >= 0 && nx < boardSize && ny < boardSize) {
                const neighborIndex = getIndex(nx, ny);
                if (cells[neighborIndex].mine) mineCounter++;
              }
            }
          }
          cells[i].adjacentMines = mineCounter;
        }
      }
    }

    // index
    function getIndex(x, y) {
      return y * boardSize + x;
    }

    function getXY(index) {
      return { x: index % boardSize, y: Math.floor(index / boardSize) };
    }

    // click
    function revealCell(cell) {
      if (gameOver || cell.revealed) return;
      cell.revealed = true;
      const cellElement = document.getElementById(`cell-${cell.id}`);
      cellElement.classList.add("revealed");

      if (cell.mine) {
        cellElement.classList.add("mine");
        cellElement.textContent = "ðŸ’£";
        gameOver = true;
        alert("Game Over! You hit a mine.");
        return;
      }

      if (cell.adjacentMines > 0) {
        cellElement.textContent = cell.adjacentMines;
      } else {
        // around
        const { x, y } = getXY(cell.id);
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < boardSize && ny < boardSize) {
              revealCell(cells[getIndex(nx, ny)]);
            }
          }
        }
      }
    }

    // create board
    function createBoard() {
      cells.forEach((cell) => {
        const cellElement = document.createElement("div");
        cellElement.id = `cell-${cell.id}`;
        cellElement.className = "cell";
        cellElement.addEventListener("click", () => revealCell(cell));
        board.appendChild(cellElement);
      });
    }

    // start
    placeMines();
    calculateAdjacentMines();
    createBoard();
  </script>
</body>
</html>
